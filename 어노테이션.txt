

어노테이션


어노테이션(annotation)은  실행하고는 상관없이 자바 소스코드에 주석문처럼 추가하는 부가적인 정보입니다. 어노테이션은 서로 다른 이름으로 구성된 정보들을
가지는 하나의 단위이며 이것을 메타데이터(metadata)라고 합니다. 어노테이션과 메타데이터는 같은 의미이며 보편적으로 많이 사용하는 용어는
어노테이션입니다. 어노테이션은 컴파일러를 비롯하여 개발에 사용되는 여러 가지 도구에 정보를 제공할
 목적으로 사용합니다.



1. 어노테이션 개요

어노테이션은 관련있는 데이터를 가진 하나의 정보입니다. 새로운 정보를 나타내고자 어노테이션을 생성하는 문법은 다음과 같습니다.

		【 어노테이션 선언 】

@interface 어노테이션명 {
	데이터 타입 변수명();
}

어노테이션을 생성하는 방법은 인터페이스를 선언하는 방법과 비슷합니다. 단지 차이가 있다면 interfce대신 @interface 키워드를
사용한다는 것입니다. 다음은 어노테이션을 생성하는 예입니다.

@interface Check {
String name();
int val();
}

이름은 Check이고 name과 val이라는 데이터 정보를 나타내는 어노테이션을 선언한 예입니다. @Check 어노테이션에 name과 val은 
추상메소드로 선언했습니다. 그러나 name과 val은 값을 가지는 변수처럼 사용되므로 필드라고 생각해도 괜찮습니다. 

@interface로 선언한 어노테이션은 자동으로 Annotation 인터페이스를 상속받습니다. 즉, Annotation은 모든 어노테이션의
상위 객체입니다. 따라서 Annotation에 선언된 모든 메소드를 어노테이션 객체에서 사용할 수 있습니다.

java.lang.annotation의 Annotation에 선언된 메소드는 다음과 같습니다.


표 Annotation의 메소드 

제어자 및 타입 					메소드					설명
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Class<? extends Annotation>			annotataionType()			어노테이션의 클래스 객체 반환

boolean						equals(Object obj)			매개변수로 전달받은 어노테이션과 논리적으로 동일한지 판단

int 			hashCode()			어노테이션의 해시코드값 반환

String			toString()				어노테이션의 문자열값 반환


2. 어노테이션 사용

어노테이션 선언은 인터페이스 선언과 비슷하지만 어노테이션 블록 안에 선언된 추상 메소드들은 값을 저장하는 변수처럼 처리한다고 했습니다.
이러한 어노테이션을 사용하는 방법은 클래스 ,메소드, 변수, 열거 상수를 선언할 때 앞부분에 다음과 같은 형식으로 사용합니다.


    【어노테이션 사용】
@어노테이션명(변수명 = 값, 변수명 = 값)

@어노테이션명은 사용하려는 어노테이션을 나타냅니다. 어노테이션에 데이터를 저장하려면 괄호()안에 어노테이션에서 선언한 '변수명 = 값' 
형식으로 지정하며, 여러 개의 값을 지정할 때는 콤마(,)를 구분자로 사용합니다.

앞에서 예시로 선언한 @Check 어노테이션을 사용하는 코드는 다음과 같습니다.

@Check(name = "first", val =123)
public static void test() {....}

위 코드는 test() 메소드 앞에 어노테이션을 지정함으로써 test() 메소드에 @Check 어노테이션을 적용합니다.
@Check 어노테이션을 생성하고 name 변수에는 first , val 변수에는 123이라는 값을 저장합니다.

3. 어노테이션 유지 정책

어노테이션은 실행과 상관없이 소스코드에 추가하는 정보들입니다. 이 정보들은 유지 범위 값에 따라서 서로 다른 범위로 사용할 수 있습니다.
어노테이션에 지정할 수 있는 유지 범위 값을 가지는 객체는 lang.annotation.RetentionPolicy 열거형 클래스입니다. RetentionPolicy에 정의된 
열거 상수는 다음과 같습니다. 

-SOURCE : 소스 파일에서만 유지하고 컴파일 때 삭제함
-CLASS : 컴파일된 바이트코드(.class)에서 유지됨.그러나 실행 때 JVM이 사용할 수 없음
-RNUTIME : 컴파일된 바이트코드(.class)에서 유지되고 실행 때 JVM이 사용 가능함

SOURCE, CLASS, RUNTIME 세 가지 중 가장 오래 유지되는 것은 RUNTIME입니다. 참고로 지역변수에 선언된 어노테이션은 바이트코드(.class)
파일에서 유지되지 않습니다. 어노테이션에서 유지 정책을 적용해 선언하려면 자바에서 기본적으로 제공하는 @Retention 어노테이션을 
지정합니다. 다음은 @Retention 어노테이션을 사용하는 방법입니다. 열거 상수는 SOURCE, CLASS, RUNTIME입니다.


 【@Retention 어노테이션 사용】
@Retention(RetentionPolicy.열거상수)

다음은 RUNTIME으로 유지 범위를 @Check 어노테이션에 적용하는 예입니다.

@Retention((RetentionPolicy.RUNTIME)
@interface Check{
String name();
int val();
}

4. 정보 추출

어노테이션은 개발 또는 배치(deployment) 도구에서 사용하고자 소스코드에 추가하는 정보입니다. 프로그램 실행 시
어노테이션 정보를 사용할 때는 리플렉션(reflection)을 사용해 정보를 추출해야합니다. 리플렉션은 클래스의 정보(선언된 클래스, 메소드,변수에 대한 정보)를
처리할 수 있게 해주는 기능입니다. 리플렉션 기능은 java.lang.reflect 패키지의 API에서 제공합니다.

4.1 리플렉션을 위한 Class 객체

리플렉션(reflection)을 사용하려면 가장 먼저 Class 객체를 생성해야 합니다. Class 객체는 클래스에 대한 정보를 가지는 객체로 다음 두 가지 방법으로
생성할 수 있습니다.

첫번째 방법은 java.lang.Object에 선언된 getClass() 메소드를 사용하는 것입니다.

final Class<?> getClass()

두번째 방법은 객체 이름 다음에 .class를 추가하는 것입니다.

Test.class 또는 Check.class

만약 Test가 일반 클래스라면 Test.class는 Test에 대한 정보를 갖는 Class 객체가 생성되고, Check가 어노테이션이라면 Check.class는 
Check 어노테이션에 대한 정보를 갖는 Class 객체가 생성됩니다.

다음은 Class 객체에서 클래스에 대한 정보를 추출하는 메소드입니다.

- Method getMethod(String) : 인자로 지정된 이름의 메소드를 Method 객체로 반환

- boolean isAnnotationPresent(Class) : 매개변수로 전달받은 어노테이션의 적용 여부 판단

- Annotation getAnnotation(Class) : 매개변수로 전달받은 어노테이션을 Anotation 객체로 반환

- Annotation[] getAnnotations() : 적용된 모든 어노테이션을 Annotation 객체로 반환

다음은 Class 객체를 생성한 후 메소드에 대한 정보를 추출하는 예제입니다.

package sec;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Method;

@Retention(RetentionPolicy.RUNTIME)
@interface Check {
	String name();
	int val();
	}
public class AnnoTest {

	@Check(name = "winwin", val =123)
	public static void test() {
		AnnoTest obj = new AnnoTest();
		try{
			Class<?>c = obj.getClass();
			Method m = c.getMethod("test");
			
			Check check = m.getAnnotation(Check.class);
			System.out.println(check.name()+ ":" + check.val());
		}catch(Exception e){
			e.printStackTrace();
		}
		}
	public static void main(String[] args) {
		test();
	}

}
-----------------------------------------------------------------------
winwin:123



소스에 대한 자세한 설명은 다음과 같습니다.

@Retention(RetentionPolicy.RUNTIME)

선언하려는 어노테이션의 적용 범위를 실행 시에도 유지될 수 있도록 설정합니다.

@interface Check {
	String name();
	int val();
	}

name과 val값을 가지는 @Check 어노테이션을 선언합니다.

@Check(name = "winwin", val =123)
	public static void test() {

test() 메소드에 @Check 어노테이션을 지정하며 name 값은 "winwin" , val 값은 123으로 설정합니다.

AnnoTest obj = new AnnoTest();
Class<?>c = obj.getClass();

obj는 AnnoTest 객체를 참조합니다. obj.getClass() 메소드는 Annotest 객체에 대한 정보를 가지는 Class 객체를 생성하여 반환합니다.


Method m = c.getMethod("test");

c는 AnnoTest의 Class 객체입니다. c.getMethod() 메소드는 클래스 정보 중 인자로 던잘한 이름의 메소드를 Method 객체로 생성하여
반환합니다. Method 객체는 메소드에 대한 정보 처리를 지원합니다.

Check check = m.getAnnotation(Check.class);

객체에 대한 정보를 가진 Class 객체를 생성하는 방법은 두 가지입니다. 첫 번째는 19번 줄처럼 Object의 getClass() 메소드를 사용하는
방법이고, 두 번째는 객체이름.class로 표현하는 방법입니다. Check.class는 Check 객체에 대한 정보를 가진 Class 객체가 생성되며 
getAnnotation() 메소드는 인자로 전달한 이름의 어노테이션을 찾아 Annotation 객체로 생성하여 반환합니다.

System.out.println(check.name()+ ":" + check.val());

check 변수는 @Check 어노테이션 객체입니다. check.val() 메소드는 @Check 어노테이션에서 val값을 추출합니다.



4.2 여러 개의 어노테이션 선언 및 활용
 
다음은 여러 개의 어노테이션을 선언하고 활용하는 예제입니다.




	
	package sec;

import java.lang.annotation.Annotation;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Method;

@Retention(RetentionPolicy.RUNTIME)
@interface Mapping {
	String mode();
	int value();
	}

@Retention(RetentionPolicy.RUNTIME)
@interface Comment {
	String msg();
	}
@Mapping(mode= "winwin", value=1000)
@Comment(msg = "Annotation2 클래스")

public class AnnoTest2 {
	
	@Mapping(mode="kun",value= 200)
	@Comment(msg= "test() 메소드")
	public static void test() {
		AnnoTest2 obj = new AnnoTest2();
		try{
			Class<?> c = obj.getClass();
			Annotation annoList[] = c.getAnnotations();
			System.out.println("클래스의 annotation 목록 ");
			for(Annotation item : annoList)
				System.out.println(item);
			
			Method m = c.getMethod("test");
			annoList = m.getAnnotations();
			System.out.println();
			for(Annotation item : annoList)
				System.out.println(item);
			
		} catch(Exception e){
			e.printStackTrace();
		}
	}
	public static void main(String[] args) {
		test();
		
	}

}



-------------------------------------실행 결과--------------------------------------------

클래스의 annotation 목록 
@sec.Mapping(mode=winwin, value=1000)
@sec.Comment(msg=Annotation2 클래스)

@sec.Mapping(mode=kun, value=200)
@sec.Comment(msg=test() 메소드)












소스에 대한 자세한 설명은 다음과 같습니다.

@Retention(RetentionPolicy.RUNTIME)
@interface Mapping {
	String mode();
	int value();
	}

@Mapping 어노테이션을 선언합니다. @Mapping 어노테이션이 가지는 정보 값은 mode와 value입니다. 08번줄에서 
@Mapping 어노테이션은 실행 시에도 사용할 수 있도록 선언했습니다.


@Retention(RetentionPolicy.RUNTIME)
@interface Comment {
	String msg();
	}

@Comment 어노테이션을 선언합니다. @Comment가 가지는 정보 값은 msg입니다.

@Mapping(mode= "winwin", value=1000)
@Comment(msg = "Annotation2 클래스")

public class AnnoTest2 {

AnnoTest2 클래스 선언 앞에 어노테이션을 지정했으므로 19-20번 줄에 지정한 어노테이션이 적용됩니다.

	@Mapping(mode="kun",value= 200)
	@Comment(msg= "test() 메소드")
	public static void test() {

test 메소드 선언 앞에 어노테이션을 지정했으므로 23-24번줄에 지정한 어노테이션이 적용됩니다.

Class<?> c = obj.getClass();

getClass() 메소드는 obj 객체의 정보를 가진 Class 객체를 생성하여 반환합니다.

Annotation annoList[] = c.getAnnotations();

class 객체의 getAnnotations() 메소드는 클래스에 정의된 어노테이션들을 Annotation 객체로 생성한 후 배열에
저장하여 반환합니다. 클래스에 정의된 어노테이션은 19-20 번 줄입니다. 따라서 annoList[] 배열에는 두 개의
Annotation 객체가 저장됩니다.


Method m = c.getMethod("test");

getMethod("test")는 test 이름으로 선언된 메소드의 정보를 가진 Method 객체를 생성하여 반환합니다.

annoList = m.getAnnotations();

m.getAnnotations() 메소드는 m이 참조하는 메소드에 정의된 어노테이션들을 Annotation 객체로 생성한 후
배열에서 저장하여 반환합니다. test() 메소드에 정의된 어노테이션은 23-24번 줄입니다. 따라서 
annoList[] 배열에는 두 개의 Anmotation 객체가 저장됩니다.



4.3 어노테이션 적용 여부 판단

다음은 어노테이션 적용 여부를 판단하는 예제입니다.

package sec;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
@interface Service {
	}
@Service
public class AnnoTest3 {

	public static void main(String[] args) {
		AnnoTest3 obj = new AnnoTest3();
		try {
			Class<?> c = obj.getClass();
			if(c.isAnnotationPresent(Service.class))
				System.out.println("Service 어노테이션을 지정함");
		} catch(Exception e){
			e.printStackTrace();
			
			
		}
		

	}



----------------------실행 결과-------------------------------------
Service 어노테이션을 지정함





소스에 대한 자세한 설명은 다음과 같습니다.

@Retention(RetentionPolicy.RUNTIME)
@interface Service {
	}

실행 시에도 사용할 수 있는 @Service 어노테이션을 선언합니다.

 @Service
public class AnnoTest3 {


클래스에 @Service 어노테이션을 지정합니다.

Class<?> c = obj.getClass();

AnnoTest3 클래스에 대한 정보를 가지는 Class 객체 c를 얻어냅니다.

c.isAnnotationPresent() 메소드는 c의 정보 중 인자로 전달한 어노테이션이 지정되었는지를 판단합니다. 
현재 예제에서는 11번 줄에서 @Service 어노테이션을 지정했으므로 true를 반환합니다.
c.isAnnotationPresent() 메소드에 인자로 어노테이션을 전달할 때는 Class 객체 형태로 전달해야하므로
Service.class 로 작성했습니다.




4.4 기본값 지정

어노테이션은 데이터의 집합입니다. 따라서 어노테이션을 사용할 때는 데이터 값을 지정해야 합니다. 
그런데 어노테이션을 사용할 때마다 값을 지정하지 않고 기본값을 지정하여 사용할 수 있습니다.
기본값을 지정할 때 사용하는 키워드는 default입니다.


4.4.1 default 키워드

어노테이션의 기본값을 지정하는 문법은 다음과 같습니다.


【 어노테이션 기본값 지정 】

@interface 어노테이션명{
데이터 타입 변수명() default 값;
}


package sec;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.reflect.Method;

@Retention(RetentionPolicy.RUNTIME)
@interface MyAnno {
	String str() default "Jeno";
	int val() default 1004;
	}

public class AnnoTest4 {
		@MyAnno
	public static void test(){
			
	AnnoTest4 obj = new AnnoTest4();
	try {
		
		Class<?> c = obj.getClass();
		Method m = c.getMethod("test");
		MyAnno anno = m.getAnnotation(MyAnno.class);
		System.out.println(anno.str() +" : "+ anno.val());
		
	} catch(Exception e){
		e.printStackTrace();
	}
}
	public static void main(String[] args) {
		test();
	}

}



-------------------실행결과-----------------------------

Jeno : 1004

소스에 대한 자세한 설명은 다음과 같습니다.

@interface MyAnno {
	String str() default "Jeno";
	int val() default 1004;
	}


@MyAnno 어노테이션을 선언합니다. 09-10번 줄에서 어노테이션의 정보 값으로 str과 val을 선언합니다. default 키워드는
정보에 기본값을 지정할 때 사용합니다. 값을 별도로 지정하지 않으면 str은 "Jeno" , val은 1004를 기본값으로 사용합니다.





4.4.2 value 

어노테이션을 사용할 때 문법은 다음과 같습니다.

 【어노테이션 사용】

@어노테이션명(변수명 =값, 변수명 = 값)

그런데 어노테이션에 지정하는 데이터값이 하나라면 다음처럼 사용할 수 있습니다.

 【데이터 값이 하나일 때】

@어노테이션명(값)

어노테이션에 하나의 값만 지정할 때는 값만 지정할 수 있는데 이때는 반드시 어노테이션에 value 이름으로 선언된 변수가 있어야 합니다.
값이 하나일 때는 name 값이 자동으로 value로 지정되기 때문입니다.

다음 코드에서는 @Bean("Member") 형식으로 값만 지정하였습니다. "Member" 문자열은 Bean의 value에 저장됩니다.

@interface Bean{
String value();
}
....
@Bean("Member")

예제를 통해 자세하게 살펴보겠습니다.


package sec;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

@Retention(RetentionPolicy.RUNTIME)
@interface Bean {
	String value();
	
	}
@Bean("Member")

public class AnnoTest5 {

	public static void main(String[] args) {
		AnnoTest5 obj = new AnnoTest5();
		try{
			Class<?> c= obj.getClass();
			Bean b = c.getAnnotation(Bean.class);
			System.out.println(b.value());
		}catch(Exception e){
			e.printStackTrace();
			
		}
		

	}

}

-------------------------------------------실행결과--------------------------------------------------------
Member




소스에 대한 자세한 설명은 다음과 같습니다.


@interface Bean {
	String value();
	
	}

value 정보를 가지는 Bean 어노테이션을 선언합니다.

@Bean("Member")

public class AnnoTest5 {

AnnoTest5 클래스에 Bean 어노테이션을 적용합니다. 어노테이션에 정보값을 지정할 때는 (이름 = 값, 이름 = 값)형태로
그런데 (값) 형식으로 지정했습니다. 이렇게 하면 자동을 value의 정보 값으로 지정됩니다. 대신, 해당 어노테이션에 반드시 value라는
이름으로 변수가 선언되어 있어야지만 올바르게 작동합니다.


5. 표준 어노테이션

표준 어노테이션은 자바 API에서 기본으로 제공하는 어노테이션을 말하며 java.lang.annotation과 java.lang 패키지에서 제공합니다.

5.1 java.lang.annotation

@Retention

현재 선언하는 어노테이션의 유지 범위를 설정합니다.

@Document

현재 선언하는 어노테이션을 자바 문서를 포함할 것인지 설정합니다. @Document는 문서에 포함을 표시하는 어노테이션으로서
별도의 값을 지정할 필요가 없습니다.

@Target

현재 선언하는 어노테이션의 적용대상을 설정합니다. @Target의 값은 ElementType 열거형 클래스에서
정의된 상수를 사용합니다. ElementType의 열거 상수는 다음과 같습니다.

(표 ElementType의 열거 상수)

상수 					적용 대상
-------------------------------------------------------------------------------------------------------------------------------------

ANNOTATION_TYPE			어노테이션 선언

CONSTRUCTOR				생성자 선언

FIELD					필드선언

LOCAL_VARIABLE				지역변수 선언

METHOD 				메소드 선언

MODULE					모듈 선언

PACKAGE					패키지 선언

PARAMETER 				매개변수 선언

TYPE					클래스, 인터페이스, 열거형 클래스 선언

TYPE_PARAMETER				타입매개변수 선언

TYPE_USE					타입 사용


예를 들어 다음처럼 선언하면 클래스, 인터페이스, 열거형 클래스를 선언하는 부분에서 사용할 수 있는 어노테이션입니다.

@Target(ElementType.TYPE)

여러 대상을 지정할 때는 다음처럼 중괄호{} 안에 콤마(,)로 구분되어 ElementType.TYPE 상수를 지정합니다.

@Target({ElementType.TYPE, ElementType.METHOD})
@Inherited

상위 객체에 선언된 어노테이션에 @Inherited가 설정되면 하위 객체에서도 상속받아 사용할 수 있습니다.
@Inherited 는 상속을 표시하는 어노테이션으로서 값을 지정할 필요가 없습니다.





5.2 java.lang

@Override

메소드에만 적용할 수 있는 어노테이션으로 메소드가 오버라이딩되었음을 나타냅니다. @Override 어노테이션은
오버라이딩된 메소드임을 표시하기 위한 것이므로 사용할 때 값을 지정할 필요가 없습니다.
만일 오버라이딩 메소드가 아닌데 사용하면 컴파일 오류가 발생합니다.

@Deprecated

@Deprecated 어노테이션은 더 이상 사용하지 않거나 사용하지 않을 것을 권장합니다. JDK 9부터는 향후
삭제될지 여부와 삭제되는 자바 버전을 값으로 지정할 수 있습니다.

@FunctionalInterface

@FunctionalInterface는 인터페이스를 선언할 때 사용하는 어노테이션입니다. @FunctionalInterface가
지정된 인터페이스를 함수형 인터페이스라고 합니다. 함수형 인터페이스는 하나의 추상 메소드만 가지는 인터페이스를 의미하는데
그건 람다식입니다. (람다식은 알아서 하기-나는 했음) 함수형 인터페이스를 선언할 때 반드시 @FunctionalInterface를 지정해야 하는 것이
아닙니다. @FunctionalInterface를 지정하지 않고 하나의 메소드만 선언된 인터페이스도 함수형 인터페이스입니다.

그렇다면 @FunctionalInterface를 지정하는 이유는 무엇일까요? 답은 컴파일 시 오류 검사가 가능하기 때문입니다.
다음 코드럼 1개 이상의 메소드가 선언된 인터페이스에 @FunctionalInterface를 지정하면 밑줄 친 곳에 컴파일 오류가 발생합니다. 

@FunctionalInterface
public interface MyInterface {
public void put();
public void get();
}

@FunctionalInterface가 지정된 인터페이스는 함수형 인터페이스, 즉 하나의 메소드만 선언된 인터페이스라는 의미이므로 하나 이상의
메소드를 선언하면 컴파일 오류가 발생합니다. 만일 @FunctionalInterface어노테이션을 지정하지 않았다면 이 오류는 발생하지
않았을 겁니다.

@SafeVarargs

@SafeVarargs 어노테이션은 메소드와 생성자에 사용할 수 있으묘 가변길이 인자를 사용할 때 발생하는 경고를 무시하려는 목적으로 사용합니다.
@SafeVarargs어노테이션을 적용하는 메소드는 반드시 접근 제한자를 static, final 또는 private으로 선언해야합니다.

다음과 같은 코드는 가변길이 인자를 사용하는 곳( 밑줄로 표시)에 경고가 발생합니다.

public class NctDream {
ArrayList<?> list = null;
public static void init(List<String> ... elements){
Object[] args = elements;
for(int i =0; i<args.length; i++){
System.out.println(args[i]);
}
}
 public static void main(String[] args ){
List<String> list1 = Array.asList("마크", "지성", "천러");
List<String> list2 = Array.asList("런쥔", "제노", "재민","동혁");
NctDream.init(list1, list2);
}
}


이때 init 메소드 선언부 앞에 @SafeVarargs 어노테이션을 지정하면 경고가 사라집니다.

@SuppressWarning

@SuppressWarning 어노테이션은 컴파일러의 경고를 무시하고자 할 때 지정합니다.








	